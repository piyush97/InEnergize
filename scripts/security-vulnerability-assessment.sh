#!/bin/bash

# InErgize Security Vulnerability Assessment Script
# Comprehensive security scanning and vulnerability assessment for production deployment
# Version: 3.0.0

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
SECURITY_DIR="$PROJECT_ROOT/infrastructure/security"
REPORTS_DIR="/tmp/inergize-security-reports"
LOG_FILE="/var/log/inergize/security-assessment.log"

# Assessment configuration
ENVIRONMENT="${ENVIRONMENT:-production}"
NAMESPACE="${NAMESPACE:-inergize-production}"
ASSESSMENT_TYPE="${ASSESSMENT_TYPE:-comprehensive}"

# Security tools configuration
ENABLE_CONTAINER_SCAN="${ENABLE_CONTAINER_SCAN:-true}"
ENABLE_K8S_SECURITY_SCAN="${ENABLE_K8S_SECURITY_SCAN:-true}"
ENABLE_NETWORK_SCAN="${ENABLE_NETWORK_SCAN:-true}"
ENABLE_DEPENDENCY_SCAN="${ENABLE_DEPENDENCY_SCAN:-true}"
ENABLE_SECRETS_SCAN="${ENABLE_SECRETS_SCAN:-true}"
ENABLE_COMPLIANCE_CHECK="${ENABLE_COMPLIANCE_CHECK:-true}"

# Registry configuration
DOCKER_REGISTRY="${DOCKER_REGISTRY:-ghcr.io/inergize}"
IMAGE_TAG="${IMAGE_TAG:-latest}"

# Thresholds
MAX_CRITICAL_VULNS="${MAX_CRITICAL_VULNS:-0}"
MAX_HIGH_VULNS="${MAX_HIGH_VULNS:-5}"
MAX_MEDIUM_VULNS="${MAX_MEDIUM_VULNS:-20}"

DRY_RUN="${DRY_RUN:-false}"

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to log messages
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# Function to show usage
show_usage() {
    cat << EOF
InErgize Security Vulnerability Assessment Script

Usage: $0 [OPTIONS]

Options:
  --environment ENV           Environment (production/staging/development)
  --namespace NAMESPACE       Kubernetes namespace to scan
  --assessment-type TYPE      Assessment type (quick/comprehensive/compliance)
  --registry REGISTRY         Docker registry URL (default: ghcr.io/inergize)
  --image-tag TAG            Docker image tag to scan (default: latest)
  --max-critical NUM          Maximum allowed critical vulnerabilities (default: 0)
  --max-high NUM             Maximum allowed high vulnerabilities (default: 5)
  --max-medium NUM           Maximum allowed medium vulnerabilities (default: 20)
  --dry-run                  Show what would be scanned without executing
  --no-container-scan        Disable container image scanning
  --no-k8s-scan             Disable Kubernetes security scanning
  --no-network-scan         Disable network security scanning
  --no-dependency-scan      Disable dependency vulnerability scanning
  --no-secrets-scan         Disable secrets scanning
  --no-compliance-check     Disable compliance checking
  --help                    Show this help message

Examples:
  $0                                          # Comprehensive security assessment
  $0 --assessment-type quick                  # Quick security scan
  $0 --environment staging --dry-run          # Dry run on staging
  $0 --no-network-scan --max-high 10         # Skip network scan, allow more high vulns

EOF
}

# Function to check prerequisites
check_prerequisites() {
    print_status "Checking security assessment prerequisites..."
    
    # Create reports directory
    mkdir -p "$REPORTS_DIR"
    mkdir -p "$(dirname "$LOG_FILE")"
    
    # Check required tools based on enabled scans
    local required_tools=("kubectl" "jq" "curl")
    
    if [[ "$ENABLE_CONTAINER_SCAN" == "true" ]]; then
        required_tools+=("trivy")
    fi
    
    if [[ "$ENABLE_K8S_SECURITY_SCAN" == "true" ]]; then
        required_tools+=("kube-bench" "kube-hunter")
    fi
    
    if [[ "$ENABLE_NETWORK_SCAN" == "true" ]]; then
        required_tools+=("nmap")
    fi
    
    if [[ "$ENABLE_DEPENDENCY_SCAN" == "true" ]]; then
        required_tools+=("npm" "yarn")
    fi
    
    if [[ "$ENABLE_SECRETS_SCAN" == "true" ]]; then
        required_tools+=("gitleaks")
    fi
    
    # Check if tools are available or install them
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            print_status "Installing $tool..."
            case $tool in
                "trivy")
                    if command -v apt-get &> /dev/null; then
                        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
                    elif command -v brew &> /dev/null; then
                        brew install trivy
                    else
                        print_error "Cannot install trivy automatically. Please install manually."
                        exit 1
                    fi
                    ;;
                "kube-bench")
                    kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench/main/job.yaml
                    ;;
                "kube-hunter")
                    pip3 install kube-hunter --quiet || print_warning "Failed to install kube-hunter"
                    ;;
                "gitleaks")
                    if command -v brew &> /dev/null; then
                        brew install gitleaks
                    else
                        curl -sSfL https://raw.githubusercontent.com/gitleaks/gitleaks/master/scripts/install.sh | sh -s -- -b /usr/local/bin
                    fi
                    ;;
                *)
                    print_error "Required tool '$tool' is not installed and cannot be auto-installed"
                    exit 1
                    ;;
            esac
        fi
    done
    
    # Check Kubernetes connectivity
    if ! kubectl cluster-info &> /dev/null; then
        print_error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    
    print_success "Prerequisites check completed"
}

# Function to scan container images
scan_container_images() {
    if [[ "$ENABLE_CONTAINER_SCAN" != "true" ]]; then
        print_status "Container image scanning disabled"
        return
    fi
    
    print_status "Scanning container images for vulnerabilities..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_status "[DRY RUN] Would scan container images with Trivy"
        return
    fi
    
    local services=("auth-service" "linkedin-service" "user-service" "analytics-service" "ai-service" "web-app")
    local total_critical=0
    local total_high=0
    local total_medium=0
    local total_low=0
    
    for service in "${services[@]}"; do
        print_status "Scanning $service image..."
        
        local image="$DOCKER_REGISTRY/$service:$IMAGE_TAG"
        local report_file="$REPORTS_DIR/trivy-$service.json"
        
        # Run Trivy scan
        if trivy image --format json --output "$report_file" "$image" 2>/dev/null; then
            # Parse results
            local critical=$(jq -r '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' "$report_file" 2>/dev/null || echo "0")
            local high=$(jq -r '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' "$report_file" 2>/dev/null || echo "0")
            local medium=$(jq -r '[.Results[]?.Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' "$report_file" 2>/dev/null || echo "0")
            local low=$(jq -r '[.Results[]?.Vulnerabilities[]? | select(.Severity=="LOW")] | length' "$report_file" 2>/dev/null || echo "0")
            
            total_critical=$((total_critical + critical))
            total_high=$((total_high + high))
            total_medium=$((total_medium + medium))
            total_low=$((total_low + low))
            
            if [[ $critical -gt 0 || $high -gt 0 ]]; then
                print_warning "$service: Critical: $critical, High: $high, Medium: $medium, Low: $low"
            else
                print_success "$service: Critical: $critical, High: $high, Medium: $medium, Low: $low"
            fi
            
            # Generate human-readable report
            trivy image --format table "$image" > "$REPORTS_DIR/trivy-$service.txt" 2>/dev/null || true
            
        else
            print_error "Failed to scan $service image"
        fi
    done
    
    # Check against thresholds
    local scan_failed=false
    
    if [[ $total_critical -gt $MAX_CRITICAL_VULNS ]]; then
        print_error "Critical vulnerabilities ($total_critical) exceed threshold ($MAX_CRITICAL_VULNS)"
        scan_failed=true
    fi
    
    if [[ $total_high -gt $MAX_HIGH_VULNS ]]; then
        print_error "High vulnerabilities ($total_high) exceed threshold ($MAX_HIGH_VULNS)"
        scan_failed=true
    fi
    
    if [[ $total_medium -gt $MAX_MEDIUM_VULNS ]]; then
        print_error "Medium vulnerabilities ($total_medium) exceed threshold ($MAX_MEDIUM_VULNS)"
        scan_failed=true
    fi
    
    # Generate consolidated report
    cat > "$REPORTS_DIR/container-scan-summary.txt" << EOF
Container Image Vulnerability Scan Summary
==========================================
Scan Date: $(date)
Environment: $ENVIRONMENT
Registry: $DOCKER_REGISTRY
Image Tag: $IMAGE_TAG

Total Vulnerabilities:
Critical: $total_critical (Threshold: $MAX_CRITICAL_VULNS)
High: $total_high (Threshold: $MAX_HIGH_VULNS)
Medium: $total_medium (Threshold: $MAX_MEDIUM_VULNS)
Low: $total_low

Status: $([ "$scan_failed" == "true" ] && echo "FAILED - Exceeds thresholds" || echo "PASSED")

Individual Service Reports:
EOF
    
    for service in "${services[@]}"; do
        if [[ -f "$REPORTS_DIR/trivy-$service.json" ]]; then
            local critical=$(jq -r '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' "$REPORTS_DIR/trivy-$service.json" 2>/dev/null || echo "0")
            local high=$(jq -r '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' "$REPORTS_DIR/trivy-$service.json" 2>/dev/null || echo "0")
            echo "$service: Critical: $critical, High: $high" >> "$REPORTS_DIR/container-scan-summary.txt"
        fi
    done
    
    if [[ "$scan_failed" == "true" ]]; then
        log_message "ERROR" "Container image scan failed security thresholds"
        return 1
    else
        print_success "Container image scan completed within security thresholds"
        log_message "INFO" "Container scan passed: Critical: $total_critical, High: $total_high, Medium: $total_medium"
        return 0
    fi
}

# Function to scan Kubernetes security
scan_kubernetes_security() {
    if [[ "$ENABLE_K8S_SECURITY_SCAN" != "true" ]]; then
        print_status "Kubernetes security scanning disabled"
        return
    fi
    
    print_status "Scanning Kubernetes cluster security configuration..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_status "[DRY RUN] Would scan Kubernetes security with kube-bench and kube-hunter"
        return
    fi
    
    # Run kube-bench (CIS Benchmark)
    print_status "Running CIS Kubernetes Benchmark..."
    local kube_bench_report="$REPORTS_DIR/kube-bench.json"
    
    # Create kube-bench job
    kubectl apply -f - <<EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: kube-bench-security-scan
  namespace: default
spec:
  template:
    spec:
      hostPID: true
      nodeSelector:
        kubernetes.io/os: linux
      tolerations:
        - key: node-role.kubernetes.io/master
          operator: Exists
          effect: NoSchedule
      containers:
        - name: kube-bench
          image: aquasec/kube-bench:latest
          command: ["kube-bench", "--json"]
          volumeMounts:
            - name: var-lib-etcd
              mountPath: /var/lib/etcd
              readOnly: true
            - name: var-lib-kubelet
              mountPath: /var/lib/kubelet
              readOnly: true
            - name: etc-systemd
              mountPath: /etc/systemd
              readOnly: true
            - name: etc-kubernetes
              mountPath: /etc/kubernetes
              readOnly: true
            - name: usr-bin
              mountPath: /usr/local/mount-from-host/bin
              readOnly: true
      restartPolicy: Never
      volumes:
        - name: var-lib-etcd
          hostPath:
            path: "/var/lib/etcd"
        - name: var-lib-kubelet
          hostPath:
            path: "/var/lib/kubelet"
        - name: etc-systemd
          hostPath:
            path: "/etc/systemd"
        - name: etc-kubernetes
          hostPath:
            path: "/etc/kubernetes"
        - name: usr-bin
          hostPath:
            path: "/usr/bin"
EOF
    
    # Wait for job completion
    kubectl wait --for=condition=complete job/kube-bench-security-scan --timeout=300s
    
    # Get kube-bench results
    kubectl logs job/kube-bench-security-scan > "$kube_bench_report"
    
    # Clean up job
    kubectl delete job kube-bench-security-scan
    
    # Run kube-hunter (penetration testing)
    if command -v kube-hunter &> /dev/null; then
        print_status "Running kube-hunter penetration testing..."
        local kube_hunter_report="$REPORTS_DIR/kube-hunter.json"
        
        kube-hunter --remote --report json > "$kube_hunter_report" 2>/dev/null || true
        
        # Parse kube-hunter results
        if [[ -f "$kube_hunter_report" ]]; then
            local vulnerabilities=$(jq -r '.vulnerabilities | length' "$kube_hunter_report" 2>/dev/null || echo "0")
            if [[ $vulnerabilities -gt 0 ]]; then
                print_warning "kube-hunter found $vulnerabilities potential security issues"
            else
                print_success "kube-hunter found no security vulnerabilities"
            fi
        fi
    fi
    
    # Scan pod security policies
    print_status "Checking pod security policies..."
    local psp_report="$REPORTS_DIR/pod-security-policies.txt"
    
    cat > "$psp_report" << EOF
Pod Security Policy Assessment
==============================
Scan Date: $(date)
Namespace: $NAMESPACE

Privileged Pods:
EOF
    
    kubectl get pods -n "$NAMESPACE" -o json | \
        jq -r '.items[] | select(.spec.securityContext.privileged == true) | .metadata.name' >> "$psp_report" || echo "None found" >> "$psp_report"
    
    cat >> "$psp_report" << EOF

Pods Running as Root:
EOF
    
    kubectl get pods -n "$NAMESPACE" -o json | \
        jq -r '.items[] | select(.spec.securityContext.runAsUser == 0 or .spec.securityContext.runAsUser == null) | .metadata.name' >> "$psp_report" || echo "None found" >> "$psp_report"
    
    cat >> "$psp_report" << EOF

Pods with Host Network:
EOF
    
    kubectl get pods -n "$NAMESPACE" -o json | \
        jq -r '.items[] | select(.spec.hostNetwork == true) | .metadata.name' >> "$psp_report" || echo "None found" >> "$psp_report"
    
    print_success "Kubernetes security scan completed"
}

# Function to scan network security
scan_network_security() {
    if [[ "$ENABLE_NETWORK_SCAN" != "true" ]]; then
        print_status "Network security scanning disabled"
        return
    fi
    
    print_status "Scanning network security configuration..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_status "[DRY RUN] Would scan network security and open ports"
        return
    fi
    
    # Get cluster external IPs
    local external_ips=($(kubectl get services --all-namespaces -o json | \
        jq -r '.items[] | select(.spec.type=="LoadBalancer") | .status.loadBalancer.ingress[]?.ip' | \
        grep -v null || true))
    
    if [[ ${#external_ips[@]} -eq 0 ]]; then
        print_status "No external LoadBalancer IPs found"
        return
    fi
    
    local network_report="$REPORTS_DIR/network-security.txt"
    
    cat > "$network_report" << EOF
Network Security Scan Report
=============================
Scan Date: $(date)
Environment: $ENVIRONMENT

External IP Addresses:
EOF
    
    for ip in "${external_ips[@]}"; do
        echo "- $ip" >> "$network_report"
        
        print_status "Scanning external IP: $ip"
        
        # Port scan with nmap
        local nmap_report="$REPORTS_DIR/nmap-$ip.txt"
        nmap -sS -O -A "$ip" > "$nmap_report" 2>/dev/null || true
        
        # Extract open ports
        local open_ports=$(grep "^[0-9]*/tcp.*open" "$nmap_report" | awk '{print $1}' | tr '\n' ' ' || echo "None")
        echo "  Open ports: $open_ports" >> "$network_report"
        
        # Check for common security issues
        if grep -q "22/tcp.*open.*ssh" "$nmap_report"; then
            print_warning "SSH port 22 is open on $ip"
            echo "  WARNING: SSH port 22 is exposed" >> "$network_report"
        fi
        
        if grep -q "80/tcp.*open.*http" "$nmap_report"; then
            print_warning "HTTP port 80 is open on $ip (should redirect to HTTPS)"
            echo "  WARNING: HTTP port 80 is exposed" >> "$network_report"
        fi
    done
    
    # Check network policies
    print_status "Checking network policies..."
    cat >> "$network_report" << EOF

Network Policies:
EOF
    
    local network_policies=$(kubectl get networkpolicy -n "$NAMESPACE" --no-headers | wc -l)
    if [[ $network_policies -gt 0 ]]; then
        echo "Found $network_policies network policies" >> "$network_report"
        kubectl get networkpolicy -n "$NAMESPACE" -o wide >> "$network_report"
    else
        echo "WARNING: No network policies found" >> "$network_report"
        print_warning "No network policies found in namespace $NAMESPACE"
    fi
    
    print_success "Network security scan completed"
}

# Function to scan dependencies
scan_dependencies() {
    if [[ "$ENABLE_DEPENDENCY_SCAN" != "true" ]]; then
        print_status "Dependency vulnerability scanning disabled"
        return
    fi
    
    print_status "Scanning application dependencies for vulnerabilities..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_status "[DRY RUN] Would scan application dependencies"
        return
    fi
    
    local dependency_report="$REPORTS_DIR/dependency-vulnerabilities.txt"
    
    cat > "$dependency_report" << EOF
Dependency Vulnerability Scan Report
====================================
Scan Date: $(date)
Project: InErgize

EOF
    
    # Scan Node.js dependencies
    if [[ -f "$PROJECT_ROOT/package.json" ]]; then
        print_status "Scanning Node.js dependencies..."
        
        cd "$PROJECT_ROOT"
        
        # Run npm audit
        local npm_audit_output
        if npm_audit_output=$(npm audit --json 2>/dev/null); then
            local npm_critical=$(echo "$npm_audit_output" | jq -r '.metadata.vulnerabilities.critical // 0')
            local npm_high=$(echo "$npm_audit_output" | jq -r '.metadata.vulnerabilities.high // 0')
            local npm_moderate=$(echo "$npm_audit_output" | jq -r '.metadata.vulnerabilities.moderate // 0')
            local npm_low=$(echo "$npm_audit_output" | jq -r '.metadata.vulnerabilities.low // 0')
            
            cat >> "$dependency_report" << EOF
Node.js Dependencies (Root):
Critical: $npm_critical
High: $npm_high
Moderate: $npm_moderate
Low: $npm_low

EOF
            
            # Save detailed report
            npm audit > "$REPORTS_DIR/npm-audit.txt" 2>/dev/null || true
            
            if [[ $npm_critical -gt 0 || $npm_high -gt 0 ]]; then
                print_warning "Found critical/high vulnerabilities in Node.js dependencies"
            else
                print_success "No critical/high vulnerabilities in Node.js dependencies"
            fi
        fi
    fi
    
    # Scan service dependencies
    for service_dir in "$PROJECT_ROOT/services"/*; do
        if [[ -d "$service_dir" && -f "$service_dir/package.json" ]]; then
            local service_name=$(basename "$service_dir")
            print_status "Scanning $service_name dependencies..."
            
            cd "$service_dir"
            
            local service_audit_output
            if service_audit_output=$(npm audit --json 2>/dev/null); then
                local critical=$(echo "$service_audit_output" | jq -r '.metadata.vulnerabilities.critical // 0')
                local high=$(echo "$service_audit_output" | jq -r '.metadata.vulnerabilities.high // 0')
                local moderate=$(echo "$service_audit_output" | jq -r '.metadata.vulnerabilities.moderate // 0')
                local low=$(echo "$service_audit_output" | jq -r '.metadata.vulnerabilities.low // 0')
                
                cat >> "$dependency_report" << EOF
$service_name Dependencies:
Critical: $critical
High: $high
Moderate: $moderate
Low: $low

EOF
                
                # Save detailed report
                npm audit > "$REPORTS_DIR/npm-audit-$service_name.txt" 2>/dev/null || true
                
                if [[ $critical -gt 0 || $high -gt 0 ]]; then
                    print_warning "Found critical/high vulnerabilities in $service_name dependencies"
                fi
            fi
        fi
    done
    
    # Scan web app dependencies
    if [[ -d "$PROJECT_ROOT/web" && -f "$PROJECT_ROOT/web/package.json" ]]; then
        print_status "Scanning web app dependencies..."
        
        cd "$PROJECT_ROOT/web"
        
        local web_audit_output
        if web_audit_output=$(npm audit --json 2>/dev/null); then
            local critical=$(echo "$web_audit_output" | jq -r '.metadata.vulnerabilities.critical // 0')
            local high=$(echo "$web_audit_output" | jq -r '.metadata.vulnerabilities.high // 0')
            local moderate=$(echo "$web_audit_output" | jq -r '.metadata.vulnerabilities.moderate // 0')
            local low=$(echo "$web_audit_output" | jq -r '.metadata.vulnerabilities.low // 0')
            
            cat >> "$dependency_report" << EOF
Web App Dependencies:
Critical: $critical
High: $high
Moderate: $moderate
Low: $low

EOF
            
            # Save detailed report
            npm audit > "$REPORTS_DIR/npm-audit-web.txt" 2>/dev/null || true
            
            if [[ $critical -gt 0 || $high -gt 0 ]]; then
                print_warning "Found critical/high vulnerabilities in web app dependencies"
            fi
        fi
    fi
    
    print_success "Dependency vulnerability scan completed"
}

# Function to scan for secrets
scan_secrets() {
    if [[ "$ENABLE_SECRETS_SCAN" != "true" ]]; then
        print_status "Secrets scanning disabled"
        return
    fi
    
    print_status "Scanning for exposed secrets and credentials..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_status "[DRY RUN] Would scan for exposed secrets"
        return
    fi
    
    local secrets_report="$REPORTS_DIR/secrets-scan.txt"
    
    # Run gitleaks on the project
    if command -v gitleaks &> /dev/null; then
        print_status "Running gitleaks secret detection..."
        
        cd "$PROJECT_ROOT"
        
        if gitleaks detect --report-format json --report-path "$REPORTS_DIR/gitleaks.json" --no-git 2>/dev/null; then
            local secrets_found=$(jq -r '. | length' "$REPORTS_DIR/gitleaks.json" 2>/dev/null || echo "0")
            
            if [[ $secrets_found -gt 0 ]]; then
                print_error "Found $secrets_found potential secrets in codebase"
                
                # Generate human-readable report
                cat > "$secrets_report" << EOF
Secrets Scan Report
==================
Scan Date: $(date)
Tool: Gitleaks

Potential secrets found: $secrets_found

Details:
EOF
                jq -r '.[] | "File: \(.File)\nLine: \(.StartLine)\nRule: \(.RuleID)\nMatch: \(.Match)\n"' "$REPORTS_DIR/gitleaks.json" >> "$secrets_report" 2>/dev/null || true
                
                return 1
            else
                print_success "No secrets detected in codebase"
                echo "No secrets detected" > "$secrets_report"
            fi
        else
            print_success "No secrets detected in codebase"
            echo "No secrets detected" > "$secrets_report"
        fi
    fi
    
    # Check Kubernetes secrets
    print_status "Checking Kubernetes secrets configuration..."
    
    cat >> "$secrets_report" << EOF

Kubernetes Secrets Analysis:
============================

Secrets in namespace $NAMESPACE:
EOF
    
    kubectl get secrets -n "$NAMESPACE" -o json | \
        jq -r '.items[] | "Name: \(.metadata.name) | Type: \(.type) | Keys: \(.data | keys | join(", "))"' >> "$secrets_report"
    
    # Check for default service account tokens
    local default_sa_secrets=$(kubectl get secrets -n "$NAMESPACE" -o json | \
        jq -r '.items[] | select(.metadata.name | startswith("default-token")) | .metadata.name' | wc -l)
    
    if [[ $default_sa_secrets -gt 0 ]]; then
        print_warning "Found $default_sa_secrets default service account tokens"
        echo "WARNING: $default_sa_secrets default service account tokens found" >> "$secrets_report"
    fi
    
    print_success "Secrets scan completed"
}

# Function to check compliance
check_compliance() {
    if [[ "$ENABLE_COMPLIANCE_CHECK" != "true" ]]; then
        print_status "Compliance checking disabled"
        return
    fi
    
    print_status "Checking compliance with security standards..."
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_status "[DRY RUN] Would check compliance with SOC2, GDPR, and security standards"
        return
    fi
    
    local compliance_report="$REPORTS_DIR/compliance-check.txt"
    
    cat > "$compliance_report" << EOF
Security Compliance Assessment
==============================
Scan Date: $(date)
Environment: $ENVIRONMENT
Standards: SOC2, GDPR, OWASP

EOF
    
    # SOC2 Compliance Checks
    print_status "Checking SOC2 compliance requirements..."
    
    cat >> "$compliance_report" << EOF
SOC2 Compliance Checklist:
==========================

EOF
    
    # Check encryption at rest
    local encrypted_secrets=$(kubectl get secrets -n "$NAMESPACE" -o json | \
        jq -r '.items[] | select(.type != "kubernetes.io/service-account-token") | .metadata.name' | wc -l)
    
    if [[ $encrypted_secrets -gt 0 ]]; then
        echo "✓ Secrets encrypted at rest: $encrypted_secrets secrets found" >> "$compliance_report"
    else
        echo "✗ No encrypted secrets found" >> "$compliance_report"
    fi
    
    # Check network policies
    local network_policies=$(kubectl get networkpolicy -n "$NAMESPACE" --no-headers | wc -l)
    if [[ $network_policies -gt 0 ]]; then
        echo "✓ Network segmentation: $network_policies network policies" >> "$compliance_report"
    else
        echo "✗ No network policies found" >> "$compliance_report"
    fi
    
    # Check RBAC
    local rbac_roles=$(kubectl get roles,rolebindings -n "$NAMESPACE" --no-headers | wc -l)
    if [[ $rbac_roles -gt 0 ]]; then
        echo "✓ Access controls: $rbac_roles RBAC rules" >> "$compliance_report"
    else
        echo "✗ No RBAC rules found" >> "$compliance_report"
    fi
    
    # Check audit logging
    if kubectl get pods -n "$NAMESPACE" -l component=audit-logger &> /dev/null; then
        echo "✓ Audit logging enabled" >> "$compliance_report"
    else
        echo "? Audit logging not explicitly configured" >> "$compliance_report"
    fi
    
    # GDPR Compliance Checks
    cat >> "$compliance_report" << EOF

GDPR Compliance Checklist:
==========================

EOF
    
    # Check data retention policies
    if kubectl get configmap data-retention-policy -n "$NAMESPACE" &> /dev/null; then
        echo "✓ Data retention policies configured" >> "$compliance_report"
    else
        echo "? Data retention policies not found" >> "$compliance_report"
    fi
    
    # Check PII encryption
    if kubectl get configmap pii-encryption-config -n "$NAMESPACE" &> /dev/null; then
        echo "✓ PII encryption configuration found" >> "$compliance_report"
    else
        echo "? PII encryption configuration not found" >> "$compliance_report"
    fi
    
    # OWASP Top 10 Checks
    cat >> "$compliance_report" << EOF

OWASP Top 10 Security Checks:
=============================

EOF
    
    # Check for security headers
    local security_headers_configured=false
    if kubectl get configmap security-headers -n "$NAMESPACE" &> /dev/null; then
        security_headers_configured=true
        echo "✓ Security headers configured" >> "$compliance_report"
    else
        echo "? Security headers configuration not found" >> "$compliance_report"
    fi
    
    # Check for rate limiting
    if kubectl get configmap rate-limiting-config -n "$NAMESPACE" &> /dev/null; then
        echo "✓ Rate limiting configured" >> "$compliance_report"
    else
        echo "? Rate limiting configuration not found" >> "$compliance_report"
    fi
    
    # Check for input validation
    if kubectl get configmap input-validation-config -n "$NAMESPACE" &> /dev/null; then
        echo "✓ Input validation configured" >> "$compliance_report"
    else
        echo "? Input validation configuration not found" >> "$compliance_report"
    fi
    
    print_success "Compliance check completed"
}

# Function to generate comprehensive report
generate_security_report() {
    print_status "Generating comprehensive security assessment report..."
    
    local final_report="$REPORTS_DIR/security-assessment-$(date +%Y%m%d_%H%M%S).txt"
    
    cat > "$final_report" << EOF
InErgize Security Vulnerability Assessment Report
================================================
Generated: $(date)
Environment: $ENVIRONMENT
Namespace: $NAMESPACE
Assessment Type: $ASSESSMENT_TYPE

Executive Summary:
=================

EOF
    
    # Determine overall risk level
    local overall_risk="LOW"
    local critical_issues=0
    local high_issues=0
    local medium_issues=0
    
    # Check container scan results
    if [[ -f "$REPORTS_DIR/container-scan-summary.txt" ]]; then
        local container_critical=$(grep "Critical:" "$REPORTS_DIR/container-scan-summary.txt" | head -n1 | awk '{print $2}' || echo "0")
        local container_high=$(grep "High:" "$REPORTS_DIR/container-scan-summary.txt" | head -n1 | awk '{print $4}' || echo "0")
        
        critical_issues=$((critical_issues + container_critical))
        high_issues=$((high_issues + container_high))
    fi
    
    # Check secrets scan results
    if [[ -f "$REPORTS_DIR/gitleaks.json" ]]; then
        local secrets_found=$(jq -r '. | length' "$REPORTS_DIR/gitleaks.json" 2>/dev/null || echo "0")
        if [[ $secrets_found -gt 0 ]]; then
            critical_issues=$((critical_issues + secrets_found))
        fi
    fi
    
    # Determine risk level
    if [[ $critical_issues -gt 0 ]]; then
        overall_risk="CRITICAL"
    elif [[ $high_issues -gt 5 ]]; then
        overall_risk="HIGH"
    elif [[ $high_issues -gt 0 ]]; then
        overall_risk="MEDIUM"
    fi
    
    cat >> "$final_report" << EOF
Overall Security Risk Level: $overall_risk

Critical Issues: $critical_issues
High Issues: $high_issues
Medium Issues: $medium_issues

Assessment Results:
==================

Container Security:
EOF
    
    if [[ -f "$REPORTS_DIR/container-scan-summary.txt" ]]; then
        tail -n +4 "$REPORTS_DIR/container-scan-summary.txt" >> "$final_report"
    else
        echo "Container scanning was disabled" >> "$final_report"
    fi
    
    cat >> "$final_report" << EOF

Network Security:
EOF
    
    if [[ -f "$REPORTS_DIR/network-security.txt" ]]; then
        tail -n +4 "$REPORTS_DIR/network-security.txt" >> "$final_report"
    else
        echo "Network scanning was disabled" >> "$final_report"
    fi
    
    cat >> "$final_report" << EOF

Secrets Analysis:
EOF
    
    if [[ -f "$REPORTS_DIR/secrets-scan.txt" ]]; then
        tail -n +4 "$REPORTS_DIR/secrets-scan.txt" >> "$final_report"
    else
        echo "Secrets scanning was disabled" >> "$final_report"
    fi
    
    cat >> "$final_report" << EOF

Compliance Assessment:
EOF
    
    if [[ -f "$REPORTS_DIR/compliance-check.txt" ]]; then
        tail -n +4 "$REPORTS_DIR/compliance-check.txt" >> "$final_report"
    else
        echo "Compliance checking was disabled" >> "$final_report"
    fi
    
    cat >> "$final_report" << EOF

Recommendations:
===============

High Priority:
EOF
    
    if [[ $critical_issues -gt 0 ]]; then
        echo "- IMMEDIATE: Address $critical_issues critical security issues" >> "$final_report"
    fi
    
    if [[ $high_issues -gt 0 ]]; then
        echo "- HIGH: Remediate $high_issues high-severity vulnerabilities" >> "$final_report"
    fi
    
    cat >> "$final_report" << EOF
- Implement automated security scanning in CI/CD pipeline
- Enable all security features (network policies, pod security policies)
- Regular security training for development team
- Quarterly penetration testing
- Implement security incident response procedures

Medium Priority:
- Enable comprehensive audit logging
- Implement data loss prevention (DLP) controls
- Regular vulnerability assessments
- Security architecture reviews
- Compliance audits (SOC2, GDPR)

Detailed Reports:
================
All detailed scan reports are available in: $REPORTS_DIR

Files generated:
$(ls -la "$REPORTS_DIR" | tail -n +2)

EOF
    
    print_success "Comprehensive security report generated: $final_report"
    
    # Display summary
    echo ""
    print_status "==== Security Assessment Summary ===="
    echo "Overall Risk Level: $overall_risk"
    echo "Critical Issues: $critical_issues"
    echo "High Issues: $high_issues"
    echo "Report Location: $final_report"
    
    # Return appropriate exit code based on findings
    if [[ "$overall_risk" == "CRITICAL" ]]; then
        return 2
    elif [[ "$overall_risk" == "HIGH" ]]; then
        return 1
    else
        return 0
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --environment)
            ENVIRONMENT="$2"
            shift 2
            ;;
        --namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --assessment-type)
            ASSESSMENT_TYPE="$2"
            shift 2
            ;;
        --registry)
            DOCKER_REGISTRY="$2"
            shift 2
            ;;
        --image-tag)
            IMAGE_TAG="$2"
            shift 2
            ;;
        --max-critical)
            MAX_CRITICAL_VULNS="$2"
            shift 2
            ;;
        --max-high)
            MAX_HIGH_VULNS="$2"
            shift 2
            ;;
        --max-medium)
            MAX_MEDIUM_VULNS="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN="true"
            shift
            ;;
        --no-container-scan)
            ENABLE_CONTAINER_SCAN="false"
            shift
            ;;
        --no-k8s-scan)
            ENABLE_K8S_SECURITY_SCAN="false"
            shift
            ;;
        --no-network-scan)
            ENABLE_NETWORK_SCAN="false"
            shift
            ;;
        --no-dependency-scan)
            ENABLE_DEPENDENCY_SCAN="false"
            shift
            ;;
        --no-secrets-scan)
            ENABLE_SECRETS_SCAN="false"
            shift
            ;;
        --no-compliance-check)
            ENABLE_COMPLIANCE_CHECK="false"
            shift
            ;;
        --help)
            show_usage
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

# Main function
main() {
    local start_time=$(date +%s)
    
    print_status "==== InErgize Security Vulnerability Assessment Started ===="
    print_status "Environment: $ENVIRONMENT"
    print_status "Assessment Type: $ASSESSMENT_TYPE"
    print_status "Namespace: $NAMESPACE"
    print_status "Dry Run: $DRY_RUN"
    
    log_message "INFO" "Security assessment started - Environment: $ENVIRONMENT, Type: $ASSESSMENT_TYPE"
    
    # Execute security assessment steps
    check_prerequisites
    
    local scan_results=()
    
    # Run enabled scans
    scan_container_images && scan_results+=("container:PASS") || scan_results+=("container:FAIL")
    scan_kubernetes_security && scan_results+=("kubernetes:PASS") || scan_results+=("kubernetes:FAIL")
    scan_network_security && scan_results+=("network:PASS") || scan_results+=("network:FAIL")
    scan_dependencies && scan_results+=("dependencies:PASS") || scan_results+=("dependencies:FAIL")
    scan_secrets && scan_results+=("secrets:PASS") || scan_results+=("secrets:FAIL")
    check_compliance && scan_results+=("compliance:PASS") || scan_results+=("compliance:FAIL")
    
    # Generate final report
    local report_result=0
    generate_security_report || report_result=$?
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # Determine overall result
    local failed_scans=0
    for result in "${scan_results[@]}"; do
        if [[ "$result" == *":FAIL" ]]; then
            ((failed_scans++))
        fi
    done
    
    if [[ "$DRY_RUN" == "true" ]]; then
        print_success "==== Security Assessment Dry Run Completed in ${duration}s ===="
        print_status "No actual scans were performed. Run without --dry-run to execute assessment."
    else
        if [[ $failed_scans -eq 0 && $report_result -eq 0 ]]; then
            print_success "==== Security Assessment Completed Successfully in ${duration}s ===="
            print_status "All security scans passed within acceptable thresholds."
        elif [[ $report_result -eq 1 ]]; then
            print_warning "==== Security Assessment Completed with Warnings in ${duration}s ===="
            print_status "Some security issues found but within acceptable risk levels."
        else
            print_error "==== Security Assessment Failed in ${duration}s ===="
            print_status "Critical security issues found that must be addressed before production deployment."
        fi
        
        print_status "Assessment Summary:"
        print_status "• Environment: $ENVIRONMENT"
        print_status "• Scans Enabled: Container:$([ "$ENABLE_CONTAINER_SCAN" == "true" ] && echo "✓" || echo "✗") K8s:$([ "$ENABLE_K8S_SECURITY_SCAN" == "true" ] && echo "✓" || echo "✗") Network:$([ "$ENABLE_NETWORK_SCAN" == "true" ] && echo "✓" || echo "✗")"
        print_status "• Reports Location: $REPORTS_DIR"
        print_status "• Duration: ${duration}s"
    fi
    
    log_message "INFO" "Security assessment completed - Duration: ${duration}s, Failed scans: $failed_scans"
    
    # Exit with appropriate code
    if [[ "$DRY_RUN" == "true" ]]; then
        exit 0
    elif [[ $report_result -eq 2 ]]; then
        exit 2  # Critical issues
    elif [[ $failed_scans -gt 0 || $report_result -eq 1 ]]; then
        exit 1  # Warnings/failures
    else
        exit 0  # Success
    fi
}

# Execute main function
main "$@"